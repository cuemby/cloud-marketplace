---
rfd: 0001
title: "Application Deployment Pattern for Cloud Marketplace"
authors:
  - name: Cuemby Engineering
state: Published
labels: [architecture, deployment, marketplace]
created: 2026-02-18
updated: 2026-02-18
discussion: null
related_prd: null
---

# RFD 0001: Application Deployment Pattern for Cloud Marketplace

## Summary

Defines the standard pattern for adding applications to the Cuemby Cloud Marketplace. Covers three deployment methods (Helm, Kustomize, raw manifests), the application structure contract, version management, parameter conventions, dependency handling, security requirements, and health checks.

Every future app PRD should reference this RFD (`source_rfd: 0001`) to ensure consistency across the catalog.

## Problem Statement

The marketplace needs a consistent, repeatable pattern for onboarding new applications. Without a standard, each app becomes a snowflake — different conventions, inconsistent parameter handling, varying security posture.

Key questions this RFD answers:

1. Which deployment method should a given app use?
2. What files and structure must every app provide?
3. How are versions, parameters, credentials, and dependencies handled?
4. What security and health-check standards apply?

## Background

The Cuemby Cloud Marketplace deploys applications on **single-node K3s VMs** — one application per VM, provisioned via cloud-init. The bootstrap flow is:

```
One-click install → Create VM → cloud-init bootstraps K3s → deploy app → health check → done
```

Three deployment methods are implemented in the codebase:
- `bootstrap/deploy-helm.sh` — Helm wrapper charts
- `bootstrap/deploy-manifest.sh` — Raw YAML manifests with `envsubst`
- `bootstrap/deploy-kustomize.sh` — Kustomize with overlays

WordPress was the first application built using this architecture (raw manifest method), serving as the reference implementation.

## Options Considered

### Option A: Helm Wrapper Charts

Wrap an upstream Helm chart in a local wrapper chart (`chart/`) that pins the dependency version and overrides values.

**Pros:**
- Low effort when a quality upstream chart exists
- Upstream security patches via version bumps
- Handles complex sub-dependencies (e.g., PostgreSQL subchart)
- Built-in templating, rollback (`--atomic`), and diffing

**Cons:**
- Licensing concerns — Bitnami charts moved to commercial VMware licensing
- Less visibility into what's actually deployed (chart abstraction)
- Upstream chart changes can break wrapper assumptions

**Effort:** Low (reuse existing chart)

**When to use:**
- Upstream chart exists with acceptable license (Apache 2.0, MIT, GPL)
- App has complex sub-dependencies the chart already handles
- You trust the upstream maintainers for ongoing security patches

### Option B: Raw Manifests with envsubst

Write all Kubernetes YAML by hand, use `${PARAM_*}` placeholders, and apply via `envsubst | kubectl apply`.

**Pros:**
- Full control over every resource — no chart abstraction
- Uses official Docker images directly (no licensing risk)
- Explicit ordering via numeric prefixes (`00-secrets.yaml`, `10-pvc.yaml`, etc.)
- Easy to audit — what you see is what gets applied

**Cons:**
- Higher effort to write all YAML from scratch
- No built-in rollback (implemented manually via `atomic_cleanup`)
- Must handle dependency ordering yourself

**Effort:** Medium (write all YAML)

**When to use:**
- Licensing concerns with available Helm charts
- You want full control with official Docker images only
- Multi-component ordering matters and you want explicit control
- App is simple enough that a chart adds unnecessary complexity

### Option C: Kustomize with Overlays

Use upstream or custom Kustomize bases with overlay directories for VM profile variants.

**Pros:**
- Native Kubernetes approach — no extra tools beyond `kubectl`
- Overlays provide clean profile separation (single, cluster, etc.)
- Good for apps distributed as Kustomize upstream

**Cons:**
- Fewer apps distribute Kustomize configurations upstream
- Limited templating (patches and replacements only)
- Overlay proliferation can become hard to manage

**Effort:** Medium

**When to use:**
- App is distributed as Kustomize upstream
- Multiple VM profile overlays are a critical requirement
- Team prefers the Kustomize declarative model

## Rejected Options

No method is rejected globally — all three are valid for different applications. This RFD provides a **decision framework** for choosing per-app rather than mandating a single approach.

## Proposal

Instead of mandating a single deployment method, this RFD defines:

1. A **decision framework** with clear criteria for choosing Helm, Manifest, or Kustomize per application
2. A **mandatory contract** that ALL applications must follow regardless of deployment method
3. **Standard conventions** for versioning, parameters, credentials, dependencies, health checks, and security

### Decision Framework

```
Does a quality upstream Helm chart exist?
├── YES → Is the license acceptable (Apache 2.0, MIT, GPL)?
│   ├── YES → Use Helm (Option A)
│   └── NO → Use Manifests (Option B) with official Docker images
└── NO → Is the app distributed as Kustomize upstream?
    ├── YES → Use Kustomize (Option C)
    └── NO → Use Manifests (Option B)
```

**Licensing check is mandatory.** Bitnami/VMware charts now require commercial licensing for production use. Always verify the license of any chart or image before adopting it.

## Implementation Considerations

### 1. Application Structure Contract

Every application MUST have the following directory structure:

```
apps/<app-name>/
├── app.yaml              # Metadata, versions, parameters, deploy method config
├── cloud-init.yaml       # Cloud-init YAML format (for providers supporting it)
├── cloud-init.sh         # Bash user-data format (for providers that don't)
├── hooks/
│   ├── pre-install.sh    # Parameter defaults, credential generation
│   ├── post-install.sh   # Post-deploy setup (wizard completion, etc.)
│   └── healthcheck.sh    # App-specific health verification
│
│  # EXACTLY ONE of the following, based on deployMethod:
├── chart/                # Helm: wrapper chart with Chart.yaml, values.yaml
├── manifests/            # Manifest: numbered YAML files (00-*.yaml, 10-*.yaml)
└── kustomize/            # Kustomize: base/ and overlays/ directories
```

### 2. app.yaml Schema

#### Common Fields (all methods)

```yaml
name: myapp                    # Unique identifier (matches directory name)
displayName: My Application    # Human-readable name
description: Short description
category: cms                  # cms, database, monitoring, ci-cd, etc.
icon: https://...              # Icon URL

deployMethod: helm|manifest|kustomize  # Deployment strategy

ssl:
  enabled: false               # true = cert-manager auto-provisioning

requirements:
  cpu: 2                       # Minimum VM CPU cores
  memory: 4Gi                  # Minimum VM memory
  disk: 30Gi                   # Minimum VM disk

versions:                      # Multi-version support
  - appVersion: "6.9.1"       # User-facing version
    default: true              # Exactly one entry must be default
    # Plus method-specific version key (see below)

parameters:                    # User-configurable parameters
  - name: MY_PARAM             # Maps to PARAM_MY_PARAM env var
    displayName: My Parameter
    description: What this parameter does
    type: string|password|number|boolean
    required: true|false
    default: "value"           # Optional default
```

#### Helm-Specific Fields

```yaml
chart:
  name: myapp
  repository: https://charts.example.com
  version: "1.0.0"            # Fallback if no versions[] match

versions:
  - appVersion: "1.0.0"
    chartVersion: "10.0.0"    # Helm dependency version
    default: true

parameters:
  - name: MY_PARAM
    helmMapping: myapp.config.myParam  # Helm --set path
```

#### Manifest-Specific Fields

```yaml
manifests:
  path: manifests/             # Directory containing YAML files

versions:
  - appVersion: "6.9.1"
    imageTag: "6.9.1-apache"   # Docker image tag
    default: true
```

#### Kustomize-Specific Fields

```yaml
kustomize:
  basePath: kustomize/base
  overlaysPath: kustomize/overlays

versions:
  - appVersion: "1.0.0"
    imageTag: "1.0.0"          # Docker image tag
    default: true
```

### 3. Version Management

The `versions[]` array maps user-facing `appVersion` values to deployment-specific identifiers:

| Deploy Method | User provides `APP_VERSION` | Resolves to |
|---|---|---|
| Helm | `appVersion` | `chartVersion` (dependency version in Chart.yaml) |
| Manifest | `appVersion` | `imageTag` (exported as `PARAM_APP_IMAGE_TAG` for envsubst) |
| Kustomize | `appVersion` | `imageTag` (used in Kustomize image transformer) |

Rules:
- Exactly one entry must have `default: true`
- If `APP_VERSION` is not provided or not found, the default entry is used
- Support the latest 2-3 version lines of the application

### 4. Parameter Convention

All user-configurable parameters follow the `PARAM_*` prefix convention:

1. **cloud-init** exports parameters as `PARAM_<NAME>` environment variables
2. **pre-install hook** (sourced, not subshelled) generates missing credentials and sets defaults
3. **deploy script** consumes parameters:
   - **Helm:** `build_set_args()` maps `PARAM_*` → `--set helmMapping=value`
   - **Manifest/Kustomize:** `envsubst` replaces `${PARAM_*}` placeholders in YAML

The `PARAM_` prefix prevents collision with system environment variables. Parameters declared in `app.yaml` use names **without** the prefix (e.g., `name: MY_PARAM`), but at runtime they're always `PARAM_MY_PARAM`.

### 5. Credential Handling

Credentials MUST follow this pattern:

1. **Auto-generation in pre-install hook:**
   ```bash
   if [[ -z "${PARAM_DB_PASSWORD:-}" ]]; then
       PARAM_DB_PASSWORD="$(openssl rand -base64 24 | tr -d '/+=' | head -c 32)"
       export PARAM_DB_PASSWORD
   fi
   ```

2. **Storage as Kubernetes Secrets** (never plaintext in Deployments):
   ```yaml
   # In manifests (envsubst replaces ${PARAM_DB_PASSWORD}):
   apiVersion: v1
   kind: Secret
   metadata:
     name: myapp-db-secret
   type: Opaque
   stringData:
     password: "${PARAM_DB_PASSWORD}"
   ```

3. **Reference via secretKeyRef in pod specs:**
   ```yaml
   env:
     - name: DB_PASSWORD
       valueFrom:
         secretKeyRef:
           name: myapp-db-secret
           key: password
   ```

Rules:
- Passwords are alphanumeric only (`tr -d '/+='`) to avoid YAML escaping issues
- Pre-install hook generates passwords if not provided by the user
- Passwords are never logged — only log "Generated password for X"
- The `type: password` field in `app.yaml` parameters signals the UI to mask input

### 6. Dependency Pattern

Each application is **self-contained** — all dependencies are deployed within the same namespace. There is no shared infrastructure between apps.

**For Helm:** Dependencies are handled via Chart.yaml `dependencies[]` — the wrapper chart pulls the upstream chart and its subcharts.

**For Manifests:** Dependencies are ordered via numeric file prefixes:

```
00-secrets.yaml       # Credentials first
05-configmap.yaml     # Configuration
10-mariadb-pvc.yaml   # Storage for database
11-wordpress-pvc.yaml # Storage for application
20-mariadb-deploy.yaml    # Database (must be up before app)
30-wordpress-deploy.yaml  # Application (with init container waiting for DB)
40-mariadb-service.yaml   # Internal services
41-wordpress-service.yaml # External service (NodePort)
```

**Init containers** ensure startup ordering:
```yaml
initContainers:
  - name: wait-for-db
    image: busybox:1.37
    command: ['sh', '-c', 'until nc -z myapp-db-svc 3306; do sleep 2; done']
```

### 7. Health Check Pattern

Health verification happens at two levels:

**Level 1: Kubernetes Probes** (in pod specs)

| Probe | Purpose | Example |
|---|---|---|
| `startupProbe` | Wait for initial setup (install wizards, migrations) | `GET /wp-admin/install.php` |
| `livenessProbe` | Detect crashes, trigger restart | `GET /wp-login.php` |
| `readinessProbe` | Gate traffic until ready | `GET /wp-login.php` |

**Level 2: App-Specific healthcheck.sh Hook**

The healthcheck hook runs after deployment and performs application-aware checks. Standard pattern (3 layers):

1. **Component connectivity** — Can the database accept connections?
2. **HTTP response** — Does the application respond with expected status codes?
3. **Storage verification** — Are all PVCs in Bound state?

The hook uses `retry_with_timeout` from `bootstrap/lib/retry.sh` for resilient checking.

### 8. Storage Pattern

- **StorageClass:** `local-path` (K3s default, appropriate for single-node)
- **Access mode:** `ReadWriteOnce` (single-node, no multi-attach needed)
- **Sizing:** Configurable via `PARAM_*_DATA_SIZE` parameters with sensible defaults
- **Volume mounts:** Application data and database data on separate PVCs

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myapp-data
spec:
  accessModes: [ReadWriteOnce]
  storageClassName: local-path
  resources:
    requests:
      storage: "${PARAM_MYAPP_DATA_SIZE}"
```

### 9. Service Exposure

- **Internal services** (databases): `ClusterIP` type, accessible only within the cluster
- **External services** (application HTTP): `NodePort` type at port `30080` (configurable via `PARAM_HTTP_NODEPORT`)
- **SSL:** Opt-in via `ssl.enabled: true` in `app.yaml`, handled by cert-manager (separate bootstrap phase)

```yaml
# Internal (database)
apiVersion: v1
kind: Service
spec:
  type: ClusterIP
  ports:
    - port: 3306

# External (application)
apiVersion: v1
kind: Service
spec:
  type: NodePort
  ports:
    - port: 80
      nodePort: ${PARAM_HTTP_NODEPORT}
```

### 10. Resource Management

The pre-install hook sets CPU and memory defaults based on the VM profile:

```bash
# Target: 2-CPU / 4GB VM
export PARAM_DB_CPU_REQUEST="${PARAM_DB_CPU_REQUEST:-250m}"
export PARAM_DB_CPU_LIMIT="${PARAM_DB_CPU_LIMIT:-1000m}"
export PARAM_DB_MEMORY_REQUEST="${PARAM_DB_MEMORY_REQUEST:-512Mi}"
export PARAM_DB_MEMORY_LIMIT="${PARAM_DB_MEMORY_LIMIT:-1Gi}"

export PARAM_APP_CPU_REQUEST="${PARAM_APP_CPU_REQUEST:-250m}"
export PARAM_APP_CPU_LIMIT="${PARAM_APP_CPU_LIMIT:-1000m}"
export PARAM_APP_MEMORY_REQUEST="${PARAM_APP_MEMORY_REQUEST:-512Mi}"
export PARAM_APP_MEMORY_LIMIT="${PARAM_APP_MEMORY_LIMIT:-2Gi}"
```

All workloads MUST have both resource requests and limits set. Never deploy without resource constraints on a shared-kernel VM.

### 11. Licensing Policy

**All images and charts must be 100% open source.** Before using any chart or image:

1. Verify the license is acceptable: Apache 2.0, MIT, GPL, BSD, MPL
2. Check that the Docker image is from an official source (e.g., `docker.io/library/wordpress`, not a third-party rebuild)
3. Bitnami/VMware charts now require commercial licensing — do NOT use them without explicit license verification
4. If a quality open-source chart doesn't exist, use raw manifests with official Docker images

## Security Considerations

1. **Password generation:** Use `openssl rand -base64 24 | tr -d '/+='` for cryptographically secure passwords
2. **Kubernetes Secrets:** All credentials stored as Secrets — never as plaintext in Deployment env vars
3. **Application hardening:** Disable admin file editing, disable auto-updates in containers, restrict dashboard access where applicable
4. **Input validation:** All `PARAM_*` values are passed through `envsubst` with an explicit variable list to prevent injection
5. **Image provenance:** Use fixed image tags (not `latest`) from official repositories only
6. **Network isolation:** Only expose the application's HTTP port via NodePort; databases use ClusterIP (internal only)

## Compatibility

No breaking changes — this is the foundational pattern. All existing and future applications follow this RFD:

- **WordPress** (`apps/wordpress/`) — reference implementation using raw manifests
- **Templates** (`apps/_template*`) — scaffolding for all three methods
- **Bootstrap scripts** (`bootstrap/deploy-*.sh`) — deploy strategies already implemented

## Open Questions

None — all decisions have been made and validated through the WordPress reference implementation.

## References

- WordPress reference implementation: `apps/wordpress/`
- Deploy strategies: `bootstrap/deploy-helm.sh`, `bootstrap/deploy-manifest.sh`, `bootstrap/deploy-kustomize.sh`
- Application templates: `apps/_template/` (Helm), `apps/_template-manifest/`, `apps/_template-kustomize/`
- Bootstrap entry point: `bootstrap/entrypoint.sh`
- Shared libraries: `bootstrap/lib/` (logging, constants, retry)
